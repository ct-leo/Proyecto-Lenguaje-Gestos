<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <title>Reconocimiento de Manos - Entrenamiento (vista02)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- MediaPipe legacy solutions via CDN (URLs) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            margin: 24px;
            color: #1f2937;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 8px;
        }

        .video-wrap {
            position: relative;
            display: inline-block;
        }
        .stage {
            display: grid;
            grid-template-columns: 1fr 260px;
            gap: 18px;
            align-items: start;
        }
        .card {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            background: #f9fafb;
        }
        .detected-letter {
            font-size: clamp(36px, 8vw, 56px);
            font-weight: 800;
            line-height: 1.1;
            margin: 8px 0;
            text-align: center;
            word-break: break-word;
        }
        /* Estilo cuando mostramos 'Procesando...' para que no desborde ni se vea enorme */
        .detected-letter.processing {
            font-size: clamp(22px, 4.5vw, 28px);
            font-weight: 700;
            letter-spacing: 0.3px;
        }
        .confidence {
            height: 10px;
            background: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }
        .confidence > span {
            display: block;
            height: 100%;
            width: 0%;
            background: #10b981;
            transition: width .2s ease;
        }

        video {
            display: block;
            width: 640px;
            height: 480px;
            border-radius: 10px;
            background: #000;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            border-radius: 10px;
            pointer-events: none; /* permitir clicks a los controles debajo si se diera el caso */
            /* sin background para que se vea el video debajo */
            z-index: 2;
            outline: 1px solid rgba(255,255,255,0.06);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-top: 16px;
        }

        .controls>* {
            margin: 0;
        }

        select,
        button {
            font-size: 14px;
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            transition: transform .05s ease, background .15s ease;
        }

        button.primary {
            background: #2563eb;
            color: #fff;
            border-color: #2563eb;
        }

        button.danger {
            background: #ef4444;
            color: #fff;
            border-color: #ef4444;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        button:not(:disabled):active {
            transform: translateY(1px);
        }

        .panel {
            margin-top: 20px;
            padding: 14px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
        }

        .row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .progress-wrap {
            flex: 1 1 auto;
            background: #e5e7eb;
            height: 12px;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-bar {
            background: #10b981;
            height: 100%;
            width: 0%;
            transition: width .25s ease;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 12px;
            background: #e0e7ff;
            color: #1e40af;
        }

        .muted {
            color: #6b7280;
        }

        /* Debug HUD */
        .hud {
            position: absolute;
            left: 8px;
            top: 8px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 6px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Entrenamiento de Lenguaje de Señas (A..Z) – vista02</h1>
        <p class="muted">Reconocimiento en navegador con MediaPipe (URL/CDN). Guardado en BD vía endpoints de
            <code>/vista02</code>.</p>

        <div class="stage">
            <div class="video-wrap">
                <video id="cam" playsinline muted autoplay></video>
                <canvas id="overlay" width="640" height="480"></canvas>
                <div id="hud" class="hud" style="display:none"></div>
            </div>
            <div class="card">
                <div class="muted" style="font-weight:600;">Letra detectada</div>
                <div id="bigLetter" class="detected-letter">–</div>
                <div class="confidence"><span id="confBar"></span></div>
                <div class="mono muted" style="text-align:center;margin-top:6px;">
                    Confianza: <span id="confPct">0%</span>
                </div>
                <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
                    <button id="btnLoadModel">Cargar modelo</button>
                    <button id="btnResetDb" class="danger">Limpiar BD</button>
                </div>
                <div id="statusMsg" class="mono muted" style="margin-top:8px;min-height:18px;"></div>
            </div>
        </div>

        <div class="controls">
            <label for="letter">Letra:</label>
            <select id="letter"></select>

            <button id="btnTrainSamples">Entrenar (capturar muestras)</button>
            <button id="btnTrainModel" class="primary">Entrenar Modelo</button>
            <button id="btnRefreshProgress">Refrescar progreso</button>
            <label class="muted" style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" id="toggleMirror" checked /> Espejar overlay
            </label>
        </div>

        <div class="panel">
            <div class="row" style="margin-bottom:10px;">
                <div><span class="tag">Progreso</span></div>
                <div class="progress-wrap">
                    <div id="bar" class="progress-bar"></div>
                </div>
                <div><span id="percent" class="mono">0%</span></div>
            </div>
            <div class="row" style="gap:22px;">
                <div>Letra seleccionada: <strong id="currentLetter">A</strong></div>
                <div>Total muestras (todas letras): <span id="totalSamples" class="mono">0</span></div>
                <div>Guardadas en BD: <span id="lastSaved" class="mono">–</span></div>
                <div>Letra detectada: <strong id="predicted">–</strong></div>
            </div>
        </div>
    </div>

    <script>
        // ========== Config ==========
        const API_BASE = "/vista02/api";
        // Base de archivos para MediaPipe Hands (legacy). El loader buscará .wasm/.tflite dentro de este path.
        const MP_HANDS_BASE = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/";
        const TARGET_SAMPLES_PER_LETTER = 150; // objetivo visual para la barra

        // ========== Estado ==========
        let videoEl, canvasEl, ctx, dpr = Math.max(1, window.devicePixelRatio || 1);
        let running = false;
        let hands;           // instancia de MediaPipe Hands (legacy)
        let cameraHelper;    // instancia de Camera de camera_utils
        let lastT = 0;       // para throttling manual si hiciera falta
        const minIntervalMs = 33; // ~30 fps máx
        let frames = 0;
        let lastFpsT = performance.now();
        let fps = 0;
        let mirrorOverlay = true;

        // Entrenamiento (batch)
        let isCapturing = false;
        const batch = [];
        const BATCH_SIZE = 10;
        const AUTO_FLUSH_MS = 1200; // envía lote aunque no llegue al tamaño
        let lastFlushAt = 0;
        // Permitir abortar el envío de un batch en curso al detener captura
        let batchAbortController = null;

        // Modelo (centroides) para predicción local
        let model = { feature_version: "v1", centroids: {}, letters: [] };
        const smoothWindow = [];
        const SMOOTH_SIZE = 7;
        let lastConf = 0;
        // Backend prediction settings
        const PREDICT_COOLDOWN_MS = 120; // un poco más rápido
        let lastPredictAt = 0;
        let predictInFlight = false;
        let predictAbortController = null;
        // Histeresis para estabilidad de letra y confianza
        const HOLD_MS = 350;           // tiempo mínimo para mantener la letra aunque fluctúe
        const RELAX_RATIO = 1.15;      // margen extra sobre el umbral para no soltar de inmediato
        let holdLetter = null;         // última letra aceptada
        let holdThr = 0;               // umbral asociado a esa letra
        let holdAt = 0;                // timestamp de la última aceptación
        // Bloqueo (lock-on) adicional para evitar parpadeos
        const LOCK_CONF_THRESHOLD = 0.50;   // conf para fijar el bloqueo
        const UNLOCK_RELAX_RATIO = 1.20;    // margen para mantener bloqueo
        const UNLOCK_GRACE_MS = 700;        // ventana de gracia antes de soltar
        const CHANGE_CONFIRM_FRAMES = 3;    // frames consecutivos de mismatch para soltar
        let lockLetter = null;
        let lockThr = 0;
        let lockUpdatedAt = 0;
        let mismatchCount = 0;
        let stopping = false;          // evita condiciones de carrera al reiniciar

        // ========== Utilidades UI ==========
        function $(id) { return document.getElementById(id); }
        // Progreso por sesión local (no DB)
        const sessionCounts = {}; // { 'A': 34, 'B': 12, ... }
        function setProgressFromSession() {
            const letter = $('letter').value;
            const count = sessionCounts[letter] || 0;
            const pct = Math.max(0, Math.min(100, Math.round(100 * count / TARGET_SAMPLES_PER_LETTER)));
            $('bar').style.width = pct + '%';
            $('percent').textContent = pct + '%';
        }
        function setTotals(total, lastLetter) {
            $('totalSamples').textContent = String(total ?? 0);
            $('lastSaved').textContent = lastLetter ? lastLetter : '–';
        }
        function setPredicted(letter, conf01) {
            const conf = Math.max(0, Math.min(1, conf01 ?? 0));
            const pct = Math.round(100 * conf);
            const showLetter = (conf >= 0.5) && !!letter;
            const text = showLetter ? letter : 'Procesando...';
            $('predicted').textContent = text;
            $('bigLetter').textContent = text;
            // Alterna estilo para evitar desbordes cuando es texto largo
            $('bigLetter').classList.toggle('processing', !showLetter);
            $('confPct').textContent = pct + '%';
            $('confBar').style.width = pct + '%';
        }
        function lettersAZ() {
            const arr = [];
            for (let c = 'A'.charCodeAt(0); c <= 'Z'.charCodeAt(0); c++) arr.push(String.fromCharCode(c));
            return arr;
        }
        function populateLetterSelect() {
            const sel = $('letter');
            sel.innerHTML = '';
            for (const L of lettersAZ()) {
                const opt = document.createElement('option');
                opt.value = opt.textContent = L;
                sel.appendChild(opt);
            }
            $('currentLetter').textContent = sel.value;
            sel.addEventListener('change', () => {
                $('currentLetter').textContent = sel.value;
                // La barra muestra progreso de SESIÓN (local)
                setProgressFromSession();
                // Los totales de DB se refrescan aparte
                refreshProgress();
            });
        }

        // ========== MediaPipe Hands (legacy) init ==========
        async function initHands() {
            hands = new window.Hands({
                locateFile: (file) => MP_HANDS_BASE + file
            });
            hands.setOptions({
                selfieMode: true,             // cámara frontal
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.3,
                minTrackingConfidence: 0.3,
            });
            hands.onResults(onResults);
        }

        // ========== Cámara ==========
        async function startCamera() {
            if (stopping) {
                // espera breve si estamos en proceso de detener
                await new Promise(r => setTimeout(r, 60));
                if (stopping) return; // evita doble inicio
            }
            try {
                // Re-crear el canvas para garantizar un contexto 2D limpio tras reinicios
                try {
                    const wrap = document.querySelector('.video-wrap');
                    const old = document.getElementById('overlay');
                    if (wrap && old) {
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'overlay';
                        newCanvas.width = old.width;
                        newCanvas.height = old.height;
                        newCanvas.style.cssText = old.style.cssText;
                        wrap.replaceChild(newCanvas, old);
                        canvasEl = newCanvas;
                        ctx = canvasEl.getContext('2d');
                    }
                } catch(_) {}
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 480,
                        frameRate: { ideal: 30, max: 30 },
                        facingMode: 'user'
                    },
                    audio: false
                });
                videoEl.srcObject = stream;
                await videoEl.play();
                // Asegura que el canvas se ajuste cuando el video tenga metadata
                if (videoEl.readyState >= 1) resizeCanvasToVideo();
                videoEl.addEventListener('loadedmetadata', resizeCanvasToVideo, { once: true });
                running = true;
                // Usar Camera helper para alimentar frames a MediaPipe Hands
                await initHands(); // fuerza re-init cada vez para evitar estados zombie
                cameraHelper = new window.Camera(videoEl, {
                    onFrame: async () => {
                        await hands.send({ image: videoEl });
                    },
                    width: 640,
                    height: 480
                });
                cameraHelper.start();
                // Mostrar HUD
                document.getElementById('hud').style.display = 'block';
                if ($('btnStartCam')) $('btnStartCam').disabled = true;
                if ($('btnStopCam')) $('btnStopCam').disabled = false;
            } catch (err) {
                console.error('Error al iniciar cámara:', err);
                alert('No se pudo acceder a la cámara. Revisa permisos del navegador y que no esté en uso por otra app.');
            }
        }
        async function stopCamera() {
            if (stopping) return;
            stopping = true;
            running = false;
            // Detener Camera helper y liberar recursos de forma determinística
            try { if (cameraHelper && cameraHelper.stop) await cameraHelper.stop(); } catch (_) {}
            cameraHelper = null;
            try { if (hands && hands.close) await hands.close(); } catch (_) {}
            hands = null; // asegurar reinicialización limpia al volver a iniciar
            // Abort pending prediction request if any
            try { predictAbortController && predictAbortController.abort(); } catch (_) {}
            predictAbortController = null;
            predictInFlight = false;
            // Reset locks/histeresis para próximo inicio
            holdLetter = null; holdThr = 0; holdAt = 0;
            lockLetter = null; lockThr = 0; lockUpdatedAt = 0; mismatchCount = 0;
            if (videoEl.srcObject) {
                for (const t of videoEl.srcObject.getTracks()) t.stop();
                videoEl.srcObject = null;
            }
            // Limpiar canvas y ocultar HUD
            try { ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); } catch(_) {}
            document.getElementById('hud').style.display = 'none';
            if ($('btnStartCam')) $('btnStartCam').disabled = false;
            if ($('btnStopCam')) $('btnStopCam').disabled = true;
            stopping = false;
        }
        function resizeCanvasToVideo() {
            const w = videoEl.videoWidth || 640;
            const h = videoEl.videoHeight || 480;
            // Canvas 1:1 con el video para drawing_utils (usa coords normalizadas con ancho/alto del canvas)
            canvasEl.width = w;
            canvasEl.height = h;
            canvasEl.style.width = w + 'px';
            canvasEl.style.height = h + 'px';
            // Asegura transform identidad
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // ========== Callback de resultados (MediaPipe Hands) ==========
        function onResults(results) {
            // Dibujar el frame de video en <video> (ya visible) y solo overlay en canvas
            // Para alinear con selfieMode=true de MediaPipe Hands, espejamos el canvas horizontalmente
            const doMirror = mirrorOverlay;
            if (doMirror) {
                ctx.setTransform(-1, 0, 0, 1, canvasEl.width, 0); // mirror X
            } else {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            const w = canvasEl.width;
            const h = canvasEl.height;

            // FPS y HUD
            frames++;
            const now = performance.now();
            if (now - lastFpsT >= 1000) { fps = frames; frames = 0; lastFpsT = now; }

            const hud = document.getElementById('hud');
            hud.textContent = `ready:${videoEl.readyState}  ${videoEl.videoWidth}x${videoEl.videoHeight} fps:${fps}  hands:${results && results.multiHandLandmarks ? results.multiHandLandmarks.length : 0}`;

            if (!results || !results.multiHandLandmarks || !results.multiHandLandmarks.length) {
                // nada detectado en este frame: limpiar predicción visible
                setPredicted(null, 0);
                return;
            }

            const allHands = results.multiHandLandmarks;
            const CONN = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20]
            ];

            for (const lms of allHands) {
                // Dibujo con helpers si están disponibles
                if (window.drawConnectors && window.drawLandmarks) {
                    window.drawConnectors(ctx, lms, CONN, { color: '#22d3ee', lineWidth: 4 });
                    window.drawLandmarks(ctx, lms, { color: '#f97316', lineWidth: 2, radius: 5 });
                }
                // Dibujo manual adicional
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 3.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                for (const [a,b] of CONN) {
                    const ax = lms[a].x * w, ay = lms[a].y * h;
                    const bx = lms[b].x * w, by = lms[b].y * h;
                    ctx.moveTo(ax, ay); ctx.lineTo(bx, by);
                }
                ctx.stroke();
                ctx.fillStyle = '#f97316';
                for (const p of lms) {
                    const x = p.x * w, y = p.y * h;
                    ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                }
            }

            // Captura de muestras cuando está entrenando
            if (isCapturing) {
                // Para entrenamiento seguimos usando solo la primera mano detectada
                const lms0 = allHands[0];
                const landmarks = lms0.map(p => ({ x: p.x, y: p.y, z: p.z }));
                batch.push({ landmarks });
                const nowB = performance.now();
                if (batch.length >= BATCH_SIZE || (nowB - lastFlushAt) >= AUTO_FLUSH_MS) {
                    lastFlushAt = nowB;
                    flushBatch();
                }
            }

            // Predicción local si tenemos modelo
            // Predicción en backend (solo landmarks) con throttling para no saturar servidor
            const now2 = performance.now();
            if (!predictInFlight && (now2 - lastPredictAt) >= PREDICT_COOLDOWN_MS) {
                const lms0 = allHands[0];
                const landmarks = lms0.map(p => ({ x: p.x, y: p.y, z: p.z }));
                // Calcular feature vector en cliente para reducir payload y CPU del backend
                const fv = extractFeatureVector(landmarks);
                if (!fv) return; // si no hay feature válido, no predecir
                predictInFlight = true;
                // Nueva petición con abort controller para soportar reinicios
                predictAbortController = new AbortController();
                fetch(`${API_BASE}/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ landmarks, feature: fv }),
                    signal: predictAbortController.signal,
                })
                .then(r => r.json())
                .then(data => {
                    lastPredictAt = performance.now();
                    if (!data || data.status !== 'ok') return;
                    const dist = typeof data.distance === 'number' ? data.distance : Infinity;
                    const thr = typeof data.threshold === 'number' ? data.threshold : 0;
                    const shapeOK = !!data.shape_ok;
                    // Usa únicamente la letra aceptada por el backend (respetar umbral y forma)
                    let L = data.letter || null;

                    // Histeresis: si no pasó el umbral pero está cerca del último aceptado, mantener
                    const nowH = performance.now();
                    const within = (dist <= thr && thr > 0);
                    if (within && L) {
                        holdLetter = L; holdThr = thr; holdAt = nowH;
                    } else if (!L && holdLetter && holdThr > 0) {
                        // si seguimos cerca del gesto anterior, mantenerlo
                        if (dist <= holdThr * RELAX_RATIO && (nowH - holdAt) <= 1000) {
                            L = holdLetter;
                        } else if ((nowH - holdAt) > HOLD_MS) {
                            holdLetter = null; holdThr = 0;
                        }
                    }

                    // Confianza con mapeo más agresivo para subir rápido cuando el gesto es claro
                    let conf = 0;
                    if (thr > 0 && isFinite(dist)) {
                        const ratio = Math.max(0, Math.min(1.25, dist / (holdLetter ? holdThr || thr : thr)));
                        const gamma = 2.2; // curva que sube rápido cuando ratio<1
                        conf = Math.max(0, Math.min(1, 1 - Math.pow(ratio, gamma))); // 1 cerca, 0 lejos
                        // Si estamos dentro del umbral del backend, sube un mínimo para asegurar UI (>50%)
                        if (dist <= thr) conf = Math.max(conf, 0.9);
                        if (L && holdLetter === L) conf = Math.max(conf, 0.85); // mantener alta si seguimos en el gesto
                    }
                    // Si la forma estricta no coincide, la confianza no debe subir
                    if (!shapeOK) {
                        L = null; // forzar 'Procesando…'
                        conf = 0;
                    }

                    // Bloqueo de gesto: fija letra y confianza mientras el gesto persista
                    if (L && conf >= LOCK_CONF_THRESHOLD) {
                        lockLetter = L;
                        lockThr = thr * 0.9 || holdThr || lockThr;
                        lockUpdatedAt = nowH;
                        mismatchCount = 0;
                    } else if (lockLetter) {
                        // Si tenemos bloqueo, mantenlo salvo que haya evidencia sostenida de cambio
                        const nearLocked = isFinite(dist) && lockThr > 0 && (dist <= lockThr * UNLOCK_RELAX_RATIO);
                        if (nearLocked || (nowH - lockUpdatedAt) <= UNLOCK_GRACE_MS) {
                            L = lockLetter;
                            conf = Math.max(conf, 0.88); // mantener confianza alta mientras persista
                            mismatchCount = 0;
                        } else {
                            mismatchCount++;
                            if (mismatchCount >= CHANGE_CONFIRM_FRAMES) {
                                // liberar bloqueo por cambio real de gesto
                                lockLetter = null;
                                lockThr = 0;
                                mismatchCount = 0;
                            } else {
                                // durante conteo, seguimos mostrando la bloqueada
                                L = lockLetter;
                                conf = Math.max(conf, 0.8);
                            }
                        }
                    }

                    smoothWindow.push(L);
                    if (smoothWindow.length > SMOOTH_SIZE) smoothWindow.shift();
                    const final = majority(smoothWindow);
                    lastConf = (lastConf * 0.7) + (conf * 0.3); // más inercia para estabilidad
                    setPredicted(final, lastConf);
                })
                .catch((e) => { /* abort o error de red */ })
                .finally(() => { predictInFlight = false; });
            }
        }

        // ========== Feature extraction (JS) (equivalente ligero al backend) ==========
        function dist(a, b) {
            const dx = a[0] - b[0], dy = a[1] - b[1], dz = a[2] - b[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        function extractFeatureVector(landmarks) {
            if (!Array.isArray(landmarks) || landmarks.length !== 21) return null;
            const pts = landmarks.map(p => [p.x, p.y, p.z]);
            const wrist = pts[0];
            const rel = pts.map(p => [p[0] - wrist[0], p[1] - wrist[1], p[2] - wrist[2]]);

            const middle_mcp = rel[9];
            const base = dist([0, 0, 0], middle_mcp);
            const mcps = [rel[5], rel[9], rel[13], rel[17]];
            const spread = (dist(mcps[0], mcps[1]) + dist(mcps[1], mcps[2]) + dist(mcps[2], mcps[3])) / 3;
            const scale = Math.max(1e-6, base + spread);
            const n = rel.map(p => [p[0] / scale, p[1] / scale, p[2] / scale]);

            const fingers = {
                thumb: [2, 3, 4],
                index: [5, 6, 8],
                middle: [9, 10, 12],
                ring: [13, 14, 16],
                pinky: [17, 18, 20],
            };
            const feat = [];
            for (const key of Object.keys(fingers)) {
                const [mcp, pip, tip] = fingers[key];
                feat.push(dist(n[tip], n[pip]));
                feat.push(dist(n[pip], n[mcp]));
            }
            const tips = [8, 12, 16, 20];
            for (let i = 0; i < tips.length - 1; i++) feat.push(dist(n[tips[i]], n[tips[i + 1]]));

            const zs = n.map(p => p[2]);
            const meanZ = zs.reduce((a, b) => a + b, 0) / zs.length;
            const varZ = zs.reduce((a, z) => a + (z - meanZ) * (z - meanZ), 0) / zs.length;
            feat.push(varZ);
            return feat;
        }

        function majority(arr) {
            const counts = {};
            for (const v of arr) { if (!v) continue; counts[v] = (counts[v] || 0) + 1; }
            let best = null, bestC = 0;
            for (const k in counts) { if (counts[k] > bestC) { best = k; bestC = counts[k]; } }
            return best;
        }

        // ========== API ==========
        async function flushBatch() {
            if (!batch.length) return;
            const letter = $('letter').value;
            const payload = { letter, samples: batch.splice(0, batch.length) };
            // Fire-and-forget para no bloquear el render ni la detección
            // Crear un AbortController para poder cancelar si el usuario detiene captura
            batchAbortController = new AbortController();
            fetch(`${API_BASE}/samples/batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                signal: batchAbortController.signal,
            })
            .then(r => r.json())
            .then(data => {
                if (data && data.status === 'ok') {
                    // Actualizar barra de SESIÓN: sumamos las insertadas en esta llamada
                    const inc = Number(data.inserted || payload.samples.length || 0) || 0;
                    sessionCounts[letter] = (sessionCounts[letter] || 0) + inc;
                    setProgressFromSession();
                    const total = Object.values(data.totals || {}).reduce((a, b) => a + b, 0);
                    setTotals(total, letter);
                }
            })
            .catch(() => {});
        }

        async function refreshProgress() {
            const r = await fetch(`${API_BASE}/progress`);
            const data = await r.json();
            if (data.status === 'ok') {
                // La barra de progreso es SOLO DE SESIÓN: no usar totales de DB aquí
                setProgressFromSession();
                setTotals(data.total, null);
            }
            const lr = await fetch(`${API_BASE}/last-detected`);
            const ld = await lr.json();
            if (ld.status === 'ok') {
                $('lastSaved').textContent = ld.letter || '–';
            }
        }

        async function trainModel() {
            const r = await fetch(`${API_BASE}/train`, { method: 'POST' });
            const data = await r.json();
            if (data.status === 'ok') {
                // descargar modelo más reciente para predicción local
                await loadLatestModel();
            }
        }

        async function loadLatestModel() {
            const mr = await fetch(`${API_BASE}/model`);
            const md = await mr.json();
            if (md.status === 'ok') {
                model.feature_version = md.feature_version;
                model.centroids = md.centroids || {};
                model.letters = md.letters || [];
            }
        }

        // ========== Event handlers ==========

        $('btnTrainSamples').addEventListener('click', async () => {
            if (!running) { $('statusMsg').textContent = 'Primero inicia la cámara.'; return; }
            if (isCapturing) {
                // Parada inmediata: abortar cualquier envío en curso y limpiar el buffer
                isCapturing = false;
                try { batchAbortController && batchAbortController.abort(); } catch(_) {}
                batchAbortController = null;
                batch.splice(0, batch.length);
                lastFlushAt = performance.now();
                $('btnTrainSamples').textContent = 'Entrenar (capturar muestras)';
                $('statusMsg').textContent = 'Captura detenida';
                await refreshProgress();
            } else {
                // empieza captura
                isCapturing = true;
                $('btnTrainSamples').textContent = 'Detener captura';
                $('statusMsg').textContent = 'Capturando muestras...';
            }
        });
        $('btnTrainModel').addEventListener('click', async () => {
            await flushBatch();
            await trainModel();
            $('statusMsg').textContent = 'Modelo entrenado y cargado. Mueve tu mano para ver la letra.';
        });
        $('btnRefreshProgress').addEventListener('click', async (ev) => {
            // No borrar DB. Solo detener captura (si estaba), vaciar batch local, limpiar predicción y refrescar conteos
            const btn = ev.currentTarget;
            btn.disabled = true;
            try {
                isCapturing = false;
                batch.splice(0, batch.length);
                smoothWindow.splice(0, smoothWindow.length);
                lastConf = 0;
                setPredicted(null, 0);
                $('btnTrainSamples').textContent = 'Entrenar (capturar muestras)';
                // Reiniciar SOLO la barra de la letra actual
                sessionCounts[$('letter').value] = 0;
                setProgressFromSession();
                await refreshProgress();
                $('statusMsg').textContent = 'Listo. Puedes seleccionar otra letra y empezar a capturar.';
            } finally {
                btn.disabled = false;
            }
        });
        $('btnLoadModel').addEventListener('click', async () => {
            await loadLatestModel();
            $('statusMsg').textContent = 'Modelo cargado. Mueve tu mano para ver la letra.';
        });

        // Limpia TODA la BD (todas las muestras y modelos). Úsalo con cuidado.
        $('btnResetDb').addEventListener('click', async (ev) => {
            const btn = ev.currentTarget;
            btn.disabled = true;
            $('statusMsg').textContent = 'Limpiando base de datos...';
            try {
                const r = await fetch(`${API_BASE}/reset`, { method: 'POST' });
                let data = null;
                try { data = await r.json(); } catch (_) { data = null; }
                if (!r.ok || !data || data.status !== 'ok') {
                    console.error('reset response', r.status, data);
                    throw new Error('Reset falló');
                }
                // limpiar estado local
                isCapturing = false;
                batch.splice(0, batch.length);
                smoothWindow.splice(0, smoothWindow.length);
                lastConf = 0;
                setPredicted(null, 0);
                $('btnTrainSamples').textContent = 'Entrenar (capturar muestras)';
                // reiniciar progreso de sesión para TODAS las letras
                for (const L of lettersAZ()) sessionCounts[L] = 0;
                setProgressFromSession();
                await refreshProgress();
                $('statusMsg').textContent = 'Base de datos limpiada. Entrena de nuevo y crea un nuevo modelo.';
            } catch (e) {
                $('statusMsg').textContent = 'Error al limpiar BD. Revisa el servidor.';
                console.error('Error reset BD:', e);
            } finally {
                btn.disabled = false;
            }
        });

        // ========== Boot ==========
        window.addEventListener('load', () => {
            videoEl = $('cam');
            canvasEl = $('overlay');
            ctx = canvasEl.getContext('2d');
            populateLetterSelect();
            // Intentar cargar el último modelo al iniciar para detección inmediata
            loadLatestModel().catch(()=>{});
            setProgressFromSession();
            refreshProgress();
            // Auto-iniciar la cámara al cargar la página (solicitará permisos del navegador)
            startCamera().catch(()=>{
                document.getElementById('statusMsg').textContent = 'No se pudo iniciar la cámara automáticamente. Revisa permisos.';
            });
        });
        window.addEventListener('resize', () => {
            if (running) resizeCanvasToVideo();
        });
        document.getElementById('toggleMirror').addEventListener('change', (e) => {
            mirrorOverlay = e.target.checked;
        });
    </script>
</body>

</html>